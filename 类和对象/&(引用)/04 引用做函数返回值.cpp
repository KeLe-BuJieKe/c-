#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;


//1、不要返回局部变量的引用、
//返回局部变量引用
int& test01()
{
	int a = 10;			//局部变量存放在四区中的----栈区内
	return a;		
}


//2、函数的调用可以作为左值------所谓的左值简单来说就是等号左边的值就称为左值
//返回静态变量引用
int& test02()
{
	static int a = 1;		
	//乍一看好像与test01函数没有区别，但是这里加上了static
	//加了static就会使该变量变为静态变量，存放在全局区中，全局区上的数据在程序结束后由系统释放
	return a;		
}
int main()
{
	//1、不要返回局部变量的引用
	int& ref = test01();
	//a是个局部变量，出了函数就会被释放
	//但是我们看到第一次结果是正确的，这是由于编译器给我们做了保留操作
	cout << "ref=" << ref << endl;		

	//当我们当输出第2次或以上时，结果就为错误，这是因为a的内存已经被释放了。
	cout << "错误的输出：ref=" << ref << endl;		

	//---------------------分界线-----------------------
	//2.函数的调用可以作为左值
	int& ref2 = test02();
	cout << "ref2=" << ref2 << endl;
	//有人就会问，这个和上面没有啥区别啊，但是我多输出几次，看看效果
	cout << "ref2=" << ref2 << endl;
	cout << "ref2=" << ref2 << endl;
	//可以明显的发现结果都是1

	//但是我们这里主要的并不是要说明这个问题
	test02() = 1000;
	//如果函数的返回值是引用，这个函数调用可以作为左值
	//这一步操作相当于把函数里面的a的引用返回回来
	//相等于a=1000；
	//看到没，这里程序并没有语法错误，下面我们输出一下ref2看看，有没有什么变化
	cout << "ref2=" << ref2 << endl;
	cout << "ref2=" << ref2 << endl;
	//此时我们可以明显的发现，ref2中的数值明显被改变成了1000
	//那么这里的ref2为什么会被改变为1000呢？
	//这是因为ref2是test02()返回值的别名，从而也被修改了
	system("pause");
	return 0;
}