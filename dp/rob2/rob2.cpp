/*213. 打家劫舍 II
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。
同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
示例 1：
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。

     示例 3：
输入：nums = [0]
输出：0

*/
#include<iostream>
#include<vector>
using namespace std;

/*首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，
 不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。
注意到当房屋数量不超过两间时，最多只能偷窃一间房屋，因此不需要考虑首尾相连的问题。如果房屋数量大于两间，
就必须考虑首尾相连的问题，第一间房屋和最后一间房屋不能同时偷窃。
如何才能保证第一间房屋和最后一间房屋不同时偷窃呢？如果偷窃了第一间房屋，则不能偷窃最后一间房屋，
因此偷窃房屋的范围是第一间房屋到最后第二间房屋；如果偷窃了最后一间房屋，则不能偷窃第一间房屋，因此偷窃房屋的范围是第二间房屋到最后一间房屋。
假设数组nums 的长度为 n。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是 [0, n-2]；如果不偷窃第一间房屋，则偷窃房屋的下标范围是[1,n−1]。
在确定偷窃房屋的下标范围之后，即可用第 rob1 打家劫舍1的方法解决。
对于两段下标范围分别计算可以偷窃到的最高总金额，其中的最大值即为在 n 间房屋中可以偷窃到的最高总金额。
*/
class Solution 
{
public:
    int _rob(vector<int>&nums)
    {
        
        size_t size = nums.size();
        if(size == 1)
        {
            return nums[0];
        }
        vector<int>dp(size+1,0);

        dp[1] = nums[0];
        dp[2] = nums[1];
        int retMax = max(dp[1],dp[2]);
        
        for(size_t i = 3; i <= size; ++i)
        {
            dp[i] = max(dp[i-2],dp[i-3])+nums[i-1];
            retMax = max(dp[i],retMax);
        }
        return retMax;
    }
    int rob(vector<int>& nums) 
    {
        size_t size = nums.size();
        if(size == 1)
        {
            return nums[0];
        }

        vector<int>part1(nums.begin(),nums.end()-1);
        vector<int>part2(nums.begin()+1,nums.end());
        int ret1 = _rob(part1);
        int ret2 = _rob(part2);

        return max(ret1,ret2);

    }
};


