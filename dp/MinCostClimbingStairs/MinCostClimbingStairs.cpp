/*
746. 使用最小花费爬楼梯
数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
示例 1：
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
 示例 2：

输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。



class Solution 
{
public:
    //时间复杂度O(n)  空间复杂度O(n)，这里空间复杂度可以优化到O(1),用2个变量保存前两个的值
    int minCostClimbingStairs(vector<int>& cost) 
    {
        size_t size = cost.size();

        vector<int>dp(size+1,0); //多开一个空间，为了表示顶部
        dp[0] = cost[0];
        dp[1] = cost[1];
        size_t i = 2;
        //定义dp[i] 的含义为到达该位置的最小花费为多少
        //dp[0]与dp[1]为初始起爬点的值，认为已经爬到了该位置
        //相对于的size的位置即是顶部的位置
        //而到达顶部是得从dp[size-1]与dp[size-2]这两个位置爬上来的，只需要取个最小的花费即可
        for(; i < size; ++i)
        {
            dp[i] = min(dp[i-1],dp[i-2])+cost[i];
        }
        dp[size] = min(dp[i-1],dp[i-2]);
        return dp[size];
    }
};
*/
