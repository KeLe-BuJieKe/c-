/*
1.若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用（ A ）存储方式最节省
时间。
A 顺序表
B 双链表
C 带头结点的双循环链表
D 单循环链表

2.下列数据结构具有记忆功能的是？( C )
A 队列
B 循环队列
C 栈
D 顺序表

3.循环两列放在一维数组A[0…M-1]中，end1指向队头元素，end2指向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，
队列中最多能容纳M-1个元素。初始时为空，下列判断队空和队满的条件中，正确的是 （ A）
A 队空：end1==end2； 队满：end1==(end2+1)modM
B 队空：end1==end2; 队满：end2==(end1+1)mod(M-1)
C 队空：end2==(end1+1)modM ; 队满：end1==（end2+1）modM
D 队空：end1==（end2+1）modM; 队满：end2==(end1+1)mod(M-1)


4.对递归程序的优化的一般的手段为（ A）
A 尾递归优化
B 循环优化
C 堆栈优化
D 停止值优化


5.将一颗有 100 个结点的完全二叉树从根这一层开始，每一层从左到右依次对结点进行编号，根节点编号为 1 ，则编号为 98 的节点的父节点编号为（ C ）
A 47
B 48
C 49
D 50


6.将一棵二叉树的根结点放入队列，然后递归的执行如下操作，将出队结点所有子结点加入队。以上操作可以实现哪种遍历？( D )
A 前序遍历
B 中序遍历
C 后序遍历
D 层序遍历


7.有 1000 个无序的整数，希望使用最快的方式找出前 50 个最大的，最佳的选择是（ C ）
A 冒泡排序
B 基数排序
C 堆排序
D 快速排序

8.以下数据结构说法，错误的是_C__?
A 红黑树插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn)
B B+树插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(logn)
C Hash表插入操作的平均时间复杂度为O(logn)，最坏时间复杂度为O(n)
D 排序链表插入操作的平均时间复杂度为O(n)，最坏时间复杂度为O(n)


9.将两个各有n个元素的有序表归并成一个有序表,最少的比较次数是( D )
A 2n
B 2n-1
C n-1
D n


10.设图G的相邻矩阵如下：
0 1 1 1 1
1 0 1 0 0
1 1 0 1 1
1 0 1 0 1
1 0 1 1 0
则G的顶点数和边数分别为( A )
A 5,8
B 4,10
C 5,6
D 4,5


11.标题：小易的升级之路 | 时间限制：1秒 | 内存限制：32768K | 语言限制： 不限
【小易的升级之路】小易经常沉迷于网络游戏.有一次,他在玩一个打怪升级的游戏,他的角色的初始能力值为 a.
在接下来的一段时间内,他将会依次遇见n个怪物,每个怪物的防御力为b1,b2,b3...bn. 
如果遇到的怪物防御力bi小于等于小易的当前能力值c,那么他就能轻松打败怪物,并 且使得自己的能力值增加bi;如果bi大于c,那他也能打
败怪物,但他的能力值只能增加bi 与c的最大公约数.那么问题来了,在一系列的锻炼后,小易的最终能力值为多少?
输入描述：
对于每组数据,第一行是两个整数n(1≤n<100000)表示怪物的数量和a表示小易的初始能力值.
然后输入n行，每行整数,b1,b2...bn(1≤bi≤n)表示每个怪物的防御力
输出描述：
对于每组数据,输出一行.每行仅包含一个整数,表示小易的最终能力值
示例1：
输入
3 50
50 105 200
5 20
30 20 15 40 100
输出
110
205


#include<iostream>
#include<vector>
using namespace std;
int maxdivisor(int num1, int num2)//求最大公约数
{
	while (num1 % num2)
	{
		int temp = num1 % num2;
		num1 = num2;
		num2 = temp;
	}
	return num2;
}
int main()
{
	int num, a;
	while (cin >> num >> a)
	{
		vector<int>arr(num);
		for (int i = 0; i<num; ++i)
		{
			cin >> arr[i];
			if (a >= arr[i])//当前能力值大于>=怪物防御
			{
				a += arr[i];
			}
			else
			{
				a += maxdivisor(a, arr[i]); //加上最大公约数
			}
		}
		cout << a << endl;
	}
	return 0;
}


标题：找出字符串中第一个只出现一次的字符 | 时间限制：1秒 | 内存限制：32768K | 语言限制： 不限
【找出字符串中第一个只出现一次的字符】
找出字符串中第一个只出现一次的字符
数据范围：输入的字符串长度满足 1<=n<=1000
输入描述：
输入几个非空字符串
输出描述：
输出第一个只出现一次的字符，如果不存在输出-1
示例1：
输入
asdfasdfo
输出
o


#include<iostream>
#include<string>
#include<unordered_map>
using namespace std;
int main()
{
	string str;
	while (cin >> str)
	{
		unordered_map<char, int>hash;
		for (auto&ch : str)
		{
			hash[ch]++; //插入，如果没有就变成了1了，不然就++了
		}
		bool flag = false;
		for (auto&m : str)
		{
			if (hash[m] == 1)
			{
				cout << m << endl;
				flag = true;
				break;
			}
		}
		if (flag == false)
		{
			cout << -1 << endl;
		}
	}
	return 0;
}
*/
