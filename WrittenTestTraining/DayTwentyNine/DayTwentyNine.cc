/*
1.X86体系结构在保护模式下中有三种地址，请问一下那种说法是正确的？( A )
A 虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址
B 线性地址先经过分段机制映射到虚拟地址，然后虚拟地址通过分页机制映射到物理地址
C 虚拟地址先经过分页机制映射到线性地址，然后线性地址通过分段机制映射到物理地址
D 线性地址先经过分页机制映射到虚拟地址，然后虚拟地址通过分段机制映射到物理地址


2.对于Linux说法，下列说法正确的是（ A ）
A 线性访问内存非法时，当前线程会进入信号处理函数
B 用mv命令移动文件时，文件的修改时间会发生变化
C ulimit -c设置的是函数调用栈的大小
D malloc函数是应用程序向操作系统申请内存的接口

解析：
A.当内存越界访问时，线程会收到信号，进而进行信号处理，调用信号处理回调函数
B.linux下文件的三个时间参数
1.内容修改时间(modification time)：这里的修改时间指的是文件的内容发生变化，而更新的时间
2.状态修改时间(change time)：这里的修改时间指的是文件的属性或者权限发生变化，而更新的时间
3.最后访问时间(access time)：这里的访问时间是指文件被读取，而更新的时间
mv命令移动文件，文件的内容修改时间和最后访问时间不会发生改变,改变的是状态修改时间
C.ulimit -c 设置的是coredump 文件的个数  coredump文件也就是核心转储文件
D.malloc是语言提供给我们的库函数，操作系统申请内存的接口指的系统调用，库函数中封装了系统调用，
库函数与系统调用是两个不同的概念


3.以下说法不正确的是（ A ）
A 进程调度中"可抢占"和"非抢占"两种方式，后者引起系统的开销更大
B 每个进程都有自己的文件描述符表，所有进程共享同一打开文件表和v-node表
C 基本的存储技术包括RAM，ROM，磁盘以及SSD，其中访问速度最慢的是磁盘，CPU的高速缓存一般是由RAM组成的
D 多个进程竞争源出现了循环等待可能造成系统死锁


4.单任务系统中两个程序A和B，其中
A程序：CPU:10s -> 设备1:5s -> CPU:5s ->设备2:10s ->CPU:10s；
B程序：设备1:10s-> CPU:10s -> 设备2:5s ->CPU:5s ->设备2:10s；
执行顺序为A->B，那么CPU的利用率是（ C ）
A 30%
B 40%
C 50%
D 60%

解析：CPU处理时间=40s  总时间80s     40 / 80 = 0.5


5.下述哪种情况会提出中断请求（ A ）
A 在键盘输入过程中，每按一次键
B 两数相加结果为零
C 计算结果溢出
D 一条系统汇编指令执行完成

解析：A:当我们键盘输入的时候，进程需要中断进行I/O读取，所以会导致程序中断运行，转而进行IO，比较典型的就是scanf
B：两个数组相加结果为0，这个是正常的程序运行时可能产生的结果，并不会导致程序中断运行
C：计算结果溢出就会截断，并不会导致程序中断运行
D：汇编指令的完成也是程序在运行的体现，并不会导致程序中断运行


6.以下哪些不是内核对象（ D ）
A 进程
B 线程
C 互斥器
D 临界区


7.如果系统的umask设置为244，创建一个新文件后，它的权限：（ C ）
A --w-r--r--
B -r-xr--r--
C -r---w--w
D -r-x-wx-wx

解析：
umask
功能说明：指定在建立文件时预设的权限掩码
创建时，文件默认666，目录某人777


8.由源代码生成可执行文件需要经过预编译，编译，汇编，链接等阶段，错误：unresolved external symbol BeginScene属于( D  )阶段错误。
A 预编译
B 编译
C 汇编
D 链接

解析：无法解析的外部符号BeginScent，说明单个文件已经编译通过，在链接时，查找外部符号没有找到，无法解析，所以是发生在链接阶段


9.程序出错在什么阶段（ F ）?
int main(void)
{
  http://www.taobao.com
  cout << "welcome to taobao" << endl;
  return 0;
}

A 预处理阶段出错
B 编译阶段出错
C 汇编阶段出错
D 链接阶段出错
E 运行阶段出错
F 程序运行正常

解析：双斜杠之后的www.taobao.com被当作注释了，那么前面的http:是否合法？这是一个C++中一个几乎不会用到的语法
带标签的语句是一种特殊的语句，使用goto时，就会跳转到标签处执行


10.有一个变量int a=0；两个线程同时进行+1操作，每个线程加100次，不加锁，最后a的值是（ B ）？
A 200
B <=200
C >=200
D 都有可能


11.给定一个全是正数的数组arr，定义一下arr的最小不可组成和的概念： 1，arr的所有非空子集中，把每个子集内的所有元素加起来会出现很多的值，其中最小的记为min，最大的记为max； 2，在区间[min,max]上，如果有一些正数不可以被arr某一个子集相加得到，那么这些正数中最小的那个，就是arr的最小不可组成和； 3，在区间[min,max]上，如果所有的数都可以被arr的某一个子集相加得到，那么max+1是arr的最小不可组成和； 举例： arr = {3,2,5} arr的min为2，max为10，在区间[2,10]上，4是不能被任何一个子集相加得到的值中最小的，所以4是arr的最小不可组成和； arr = {3,2,4} arr的min为2，max为9，在区间[2,9]上，8是不能被任何一个子集相加得到的值中最小的，所以8是arr的最小不可组成和； arr = {3,1,2} arr的min为1，max为6，在区间[2,6]上，任何数都可以被某一个子集相加得到，所以7是arr的最小不可组成和； 请写函数返回arr的最小不可组成和。


class Solution {
public:
	
	 	正数数组中的最小不可组成和
	 	输入：正数数组arr
	 	返回：正数数组中的最小不可组成和
	 
	int getFirstUnFormedNum(vector<int> arr, int len) {
        int min = arr[0];
        int max = 0;
        for (auto& num : arr){
            min = std::min(min, num);
            max += num;
        }
        std::vector<int> dp(max + 1, 0);
        for (int i = 0; i < len; ++i)
        {
            for (int j = max; j >= arr[i]; --j)
            {
                if (dp[j] < (dp[j - arr[i]] + arr[i]))
                {
                    dp[j] = dp[j - arr[i]] + arr[i];
                }
            }
        }
        for (int i = min; i <= max; ++i)
        {
            if (i != dp[i])
            {
                return i;
            }
        }
        return max + 1;
    }
};


12.有假币描述居然有假币！ 现在猪肉涨了，但是农民的工资却不见涨啊，没钱怎么买猪肉啊。nowcoder这就去买猪肉，结果找来的零钱中有假币！！！可惜nowcoder 一不小心把它混进了一堆真币里面去了。只知道假币的重量比真币的质量要轻，给你一个天平（天平两端能容纳无限个硬币），请用最快的时间把那个可恶的假币找出来。
输入描述：
1≤n≤2^30,输入0结束程序。
输出描述：
最多要称几次一定能把那个假币找出来？
示例1
输入：
3
12
0
输出：
1
3
#include<iostream>
#include<vector>
using namespace std;

int getNum(int num)
{
    int count=0;
    while(num>1)
    {
        if(num%3==0)
        {
            num=num/3;
        }
        else
        {
            num=num/3+1;
        }
        count++;
    }
    return count;
}


int main()
{
    int n;
    while(cin>>n)
    {
        if(n==0)
        {
            break;
        }
        cout<<getNum(n)<<endl;
    }
    return 0;
}
*/
