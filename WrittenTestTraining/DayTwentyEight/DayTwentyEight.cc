/*
1.下面的程序执行输出几个hello？( D )
#include<stdio.h>
#include <unistd.h>
int main() {
    fork();
    fork();
    fork();
    printf("hello\n");
    return 0;
}
A 3
B 4
C 6
D 8



2.有一个程序中有A,B,C三个线程同时对一个文件进行读写操作，其中的A,B是写进程只负责往里面写数据，C是读线程，同时把读取的数据从文件中删除，A线程单独
写满文件需要10个小时，B单独写程序需要6小时，C线程需要15小时才能读取完整个文件，不考虑三个线程之间的相互影响的情况下现在_A___小时才能写满文件
A 5
B 6
C 5.5
D 4.5
E 4.8
F 5.3


3.系统中内存不足程序所需大小，程序就无法执行。( A )
A 错
B 对


4.通常所说的"存储保护"的基本含义是（ C ）。
A 防止存储器硬件受损
B 防止程序在内存丢失
C 防止程序间相互越界访问
D 防止程序被人偷看


5.下列进程调度算法中，（ B ）可能会出现进程长期得不到调度的情况。
A 非强占式静态优先权法
B 强占式静态优先权法
C 时间片轮转调度算法
D 非强占式动态优先权法


6.如果信号量的当前值为－4，则表示系统中在该信号量上有（ A ）个进程等待。
A 4
B 3
C 5
D 0


7.设两个进程共用一个临界资源的互斥信号量mutex=1，当mutex＝－1时表示（ A ）。
A 一个进程进入了临界区，另一个进程等待
B 没有一个进程进入临界区
C 两个进程都进入临界区
D 两个进程都在等待


8.若系统中只有用户级线程，则处理机调度单位是( B )。
A 线程
B 进程
C 程序
D 作业


9.一个在线服务器通常需要读取存储着海量数据的数据库。为了提高服务器处理速度，通常需要加cache（缓存），以下场景中不适合使用cache的是( A )
A 数据库中每条数据被访问的概率近似相等，且独立
B 使用了多线程机制的服务
C 单条线程尺寸太小的数据
D 有着大量访问的服务


10.计算机操作系统的主要功能是（ A ）
A 管理计算机系统的软硬件资源，以充分发挥计算机资源的效率，并为其它软件提供良好的运行环境
B 把高级程序设计语言和汇编语言编写的程序翻译到计算机硬件可以直接执行的目标程序，为用户提供良好的软件开发环境
C 对各类计算机文件进行有效的管理，并提交计算机硬件高效处理
D 为用户提供方便地操作和使用计算机

解析：操作系统作为计算机系统的资源的管理者，它的主要功能是对系统所有的软硬件资源进行合理而有效的管理和调度，提高计算机系统的整体性能。


11.标题：奇数位上都是奇数或者偶数位上都是偶数 | 时间限制：1秒 | 内存限制：32768K | 语言限制：C++、Java
给定一个长度不小于2的数组arr。 写一个函数调整arr，使arr中要么所有的偶数位上都是偶数，要么所有的奇数位上都是奇数上。 要求：如果数组长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1),下标0,2,4,6...算作偶数位,下标1,3,5,7...算作奇数位，例如[1,2,3,4]调整为[2,1,4,3]即可



class Solution 
{
public:
    
       奇数位上都是奇数或者偶数位上都是偶数
       输入：数组arr，长度大于2
       len：arr的长度
       将arr调整成奇数位上都是奇数或者偶数位上都是偶数
     
    void oddInOddEvenInEven(vector<int>& arr, int len)
    {
        int oddindex=1; //奇数位
        int evenindex=0; //偶数位
        while( evenindex<len && oddindex<len )
        {
            if(arr[evenindex]%2==0)  //这一步将在偶数位上来找奇数
            {
                evenindex+=2;
                continue;
            }
            
            if(arr[oddindex]%2==1)   //这里是奇数位来找偶数
            {
                oddindex+=2;
                continue;
            }
            swap(arr[oddindex],arr[evenindex]);  //最后将两个数的位置进行交换
            oddindex+=2;
            evenindex+=2;
        }
    }
};



12.标题：猴子分桃 | 时间限制：1秒 | 内存限制：32768K | 语言限制：不限
老猴子辛苦了一辈子，给那群小猴子们留下了一笔巨大的财富——一大堆桃子。老猴子决定把这些桃子分给小猴子。
第一个猴子来了，它把桃子分成五堆，五堆一样多，但还多出一个。它把剩下的一个留给老猴子，自己拿走其中的一堆。
第二个猴子来了，它把桃子分成五堆，五堆一样多，但又多出一个。它把多出的一个留给老猴子，自己拿走其中的一堆。
后来的小猴子都如此照办。最后剩下的桃子全部留给老猴子。
这里有n只小猴子，请你写个程序计算一下在开始时至少有多少个桃子，以及最后老猴子最少能得到几个桃子。
输入描述：
输入包括多组测试数据。
每组测试数据包括一个整数n(1≤n≤20)。
输入以0结束，该行不做处理。
输出描述：
每组测试数据对应一行输出。
包括两个整数a，b。
分别代表开始时最小需要的桃子数，和结束后老猴子最少能得到的桃子数。
示例1：
输入
5\n1\n0
输出
3121 1025\n1 1


#include<iostream>
#include<math.h>
using namespace std;

设一开是有X个桃
那么第一次分完就剩 (X-1)*(4/5)=(4/5)*x-(4/5)
第二次分完剩     (4/5)((4/5)(x-1)-1)=(4/5)^2*x-(4/5)^2-(4/5)
第三次分完剩      (4/5)((4/5)((4/5)(x-1)-1)-1)=(4/5)^3*x-(4/5)^3-(4/5)^2-(4/5)
....
依次类推，当有n个猴子经过这样处理时时，我们就可以得出剩余的桃子数为：
(x)*(4/5)^n-(4/5)^n-(4/5)^(n-1)-...-(4/5)
根据等比求和公式
4      1-（4/5)^n
—— ×  ------------ = 4[1-(4/5)^n]
5       1-(4/5) 
(((4/5)^n)*x-4[1-(4/5)^n])
故最后得到剩余桃子数(x+4)*(4/5)^n-4  
而因为有n只猴子，则老猴子就可以得到n个，而最后剩下的桃子数为(x+4)*(4/5)^n-4+n
化简为：n+4^n-4
而桃子最少需要的数量就为x+4=5^n
                    x=5^n-4


int main()
{
    int n;
    while(cin>>n)
    {
        if(n==0)
        {
            break;
        }
        else
        {
            cout<<(long long)pow(5,n)-4<<" "<<(long long)pow(4,n)+n-4<<endl;
        }
    }
    return 0;
}

*/
