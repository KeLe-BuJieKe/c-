/*
1.一进程刚获得三个主存块的使用权，若该进程访问页面的次序是｛1321215123｝，采用LRU算法时，缺页数
是___C___次。
A 3
B 4
C 5
D 6

解析：一开始1、3、2缺页，后面得5缺页以及最后得3缺页，总共缺页5次


2.以下关于多线程的叙述错误的是：( C )
A 线程同步的方法包括使用临界区，互斥量，信号量等
B 两个线程同时对简单类型全局变量进行写操作也需要互斥
C 实现可重入函数时，对自动变量也要用互斥量加以保护
D 可重入函数不可以调用不可重入函数

解析：C.可重入函数可认为是可以被中断的函数，自动变量定义的时候才被创建，函数返回时，系统回收空间，
他是的是局部作用域变量，不需要互斥量。可重入函数对全局变量才需要互斥量保护。


3.系统死锁的可能的原因是( B )
A 进程死循环
B 资源循环等待
C 程序内存访问越界
D 进程释放资源


4.整数0x12345678，在采用bigendian中内存的排序序列是（ A ）
A 12 34 56 78
B 78 56 34 12
C 87 65 43 21
D 21 43 65 87


5.使用C语言将一个1G字节的字符数组从头到尾全部设置为字’A’，在一台典型的当代PC上，需要花费的CPU时间的数级最接近( B )
A 0.001秒
B 1秒
C 100秒
D 2小时

解析：执行1条语句约1ns即10的-9次方秒，1G=1024M=1024*1024k=1024*1024*1024byte，
每次赋值1byte都要执行一次语句，故至少花费1024*1024*1024*10^-9=1.073741824s


6.对于普通的计算机，对以下事件的平均耗时从小到大排序为_A___：
A.读取1KB内存数据 B.从硬盘连续读取1KB数据 C.读取一次L2缓存 D.一次磁盘寻道
A：C,A,D,B
B：C,D,A,B
C：D,C,A,B
D：D,A,C,B


7.分页式虚拟存储管理系统中，页面的大小与可能产生的缺页中断次数（ C ）
A 成正比
B 成反比
C 无关
D 成固定值


8.关于子进程和父进程的说法，下面哪一个是正确的？（ D ）
A 一个父进程可以创建若干个子进程，一个子进程可以从属于若干个父进程
B 父进程被撤销时，其所有子进程也被相应撤消
C 子进程被撤销时，其从属的父进程也被撤销
D 一个进程可以没有父进程或子进程

解析：init(1)号进程，就是没有父进程的。
一个孩子只有一个父亲。 爹死了，孩子可以活着，是个孤儿。 孩子死了，爹也可以活着


9.关于线程和进程，下面说法正确的是（ C ）
A 终止一个进程比终止一个线程花费的时间少
B 进程切换比同一进程内部的线程切换花费的时间少
C 线程提高了不同执行程序间的通信效率
D 进程和线程都是资源分配和调度的基本单位


10.进程调度时，下列进程状态的变化过程哪一项是不可能发生的？（ C ）
A 阻塞挂起->阻塞
B 就绪挂起->就绪
C 就绪挂起->阻塞挂起
D 阻塞挂起->就绪挂起


11.标题：星际密码 | 时间限制：1秒 | 内存限制：32768K | 语言限制： 不限
【星际密码】星际战争开展了100年之后，NowCoder终于破译了外星人的密码！他们的密码是一串整数，通过一张表里的信息映射成最终4位密码。表的规则是：n
对应的值是矩阵X的n次方的左上角，如果这个数不足4位则用0填充，如果大于4位的则只输出最后4位。
|1 1|^n => |Xn ..|
|1 0| |.. ..|
例如n=2时，
|1 1|^2 => |1 1| * |1 1| => |2 1|
|1 0| |1 0| |1 0| |1 1|
即2对应的数是“0002”。
输入描述：
输入有多组数据。
每组数据两行：第一行包含一个整数n (1≤n≤100)；第二行包含n个正整数Xi (1≤Xi≤10000)
输出描述：
对应每一组输入，输出一行相应的密码。
示例1：
输入
6
18 15 21 13 25 27
5
1 10 100 1000 10000
输出
418109877711037713937811
00010089410135017501

#include<iostream>
#include<vector>
using namespace std;

| 1 | 1 |^1 n=1 | 1 | 1 | 结果为1
| 1 | 0 |       | 1 | 0 |
| 1 | 1 |^2 n=2 | 2 | 1 | 结果为2
| 1 | 0 |       | 1 | 1 |
| 1 | 1 |^3 n=3 | 3 | 2 | 结果为3
| 1 | 0 |       | 2 | 1 |
| 1 | 1 |^4 n=4 | 5 | 3 | 结果为5
| 1 | 0 |       | 3 | 2 |
| 1 | 1 |^5 n=5 | 8 | 5 | 结果为8
| 1 | 0 |       | 5 | 3 |
| 1 | 1 |^6 n=6 | 13| 8 | 结果为13
| 1 | 0 |       | 8 | 5 |

//从上面的分析我们可以发现这个矩阵左上角的值就是符合斐波那且数列的特征，故我们直接求得斐波那且数列即可
int fib(int n)
{
    if (n < 2)
    {
        return 1;
    }
    int a = 1;
    int b = 1;
    int c;
    while (--n)
    {
        c = (a + b) % 10000;
        a = b % 10000;
        b = c % 10000;
    }
    return c;
}
int main()
{
    int n;
    while (cin >> n)
    {
        vector<int>arr(n, 0);
        for (auto& e : arr)
        {
            cin >> e;
        }
        for (size_t i = 0; i < n; ++i)
        {
            printf("%04d", fib(arr[i]));
        }
        cout << endl;
    }
    return 0;
}


12.标题：数根 | 时间限制：1秒 | 内存限制：32768K | 语言限制： 不限
【数根】数根可以通过把一个数的各个位上的数字加起来得到。如果得到的数是一位数，那么这个数就是数根；如果结果是两位数或者包括更多位的数字，那么再把
这些数字加起来。如此进行下去，直到得到是一位数为止。
比如，对于24 来说，把2 和4 相加得到6，由于6 是一位数，因此6 是24 的数根。
再比如39，把3 和9 加起来得到12，由于12 不是一位数，因此还得把1 和2 加起来，最后得到3，这是一个一位数，因此3 是39 的数根。
现在给你一个正整数，输出它的数根。
输入描述：
输入包含多组数据。
每组数据数据包含一个正整数n（1≤n≤10E1000）。
输出描述：
对应每一组数据，输出该正整数的数根。
示例1：
输入
24\n39
输出
6\n3


#include<iostream>
#include<string>
#include<vector>
using namespace std;
int GetDigit(string& str)
{
    int n = 0;
    size_t size = str.size();
    for (size_t i = 0; i < size; ++i)
    {
        n += (str[i] - '0');
    }
    return n;
}
void GetDigitNum(vector<int>& arr, int num)
{
    while (num)
    {
        arr.push_back(num % 10);
        num /= 10;
    }
}
int GetRoot(vector<int>& arr)
{
    int ret = 0;
    for (auto& e : arr)
    {
        ret += e;
    }
    return ret;
}

int main()
{
    string n;
    while (cin >> n)
    {
        vector<int>arr;
        int num = GetDigit(n); //得到要处理的整数
        GetDigitNum(arr, num); //得到要处理的整数的位数
        int ret = 0;
        while ((ret = GetRoot(arr)) > 9)
        {
            arr.clear();
            GetDigitNum(arr, ret);
        }
        cout << ret << endl;
    }
    return 0;
}

*/
